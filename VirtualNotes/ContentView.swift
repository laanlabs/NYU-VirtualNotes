//
//  ContentView.swift
//  VirtualNoteTest
//
//  Created by jclaan on 4/3/22.
//

import SwiftUI
import RealityKit
import ARKit


struct ContentView : View {
    
    
    @State private var showContentOverlay = false

    
    var body: some View {
        
        VStack{
        
        //Load the AR View
        ARViewContainer().edgesIgnoringSafeArea(.all)
                  .overlay(
                    
                    
                    VStack {
                    
                        //show the view if toggel is on
                        if showContentOverlay {
                            
                            ContentOverlay()
                          
                        }
                    
                        
                        HStack{
                        
                            
                            Button(!showContentOverlay ? "Show Popup" : "Hide Popup") {
                                showContentOverlay.toggle()
                            }
                          
                            
                        }
                    }
                    
                    ,alignment: .bottom)
            
        }
    }
}


//The AR View
struct ARViewContainer: UIViewRepresentable {
    
    
    //Loads the reality composer file -- the method names are autogenerated from from the "Experience" Reality File
    let printerSceneAnchor = try! Experience.loadPrinterScene()

    func makeCoordinator() -> ARViewCoordinator {
        ARViewCoordinator(container: self)
    }
    
    
    func makeUIView(context: Context) -> ARView {
        
        let arView = ARView(frame: .zero)
        
        arView.session.delegate = context.coordinator

        
        
        
                        
        // Add the printerSceneAnchor anchor to the scene
        arView.scene.anchors.append(printerSceneAnchor)
        
        //add touch guesters to scene
        arView.setupGestures()
        arView.installGestures(.all, for: printerSceneAnchor.printerObj as! HasCollision)

        
        
        //hide the sign
        self.printerSceneAnchor.sign1Obj?.isEnabled = false

        
        return arView
        
    }
    
    func updateUIView(_ uiView: ARView, context: Context) {
    
        print("UPDATE UI")
        
        

    }
    

    func tapHandler( entity : Entity){
        
        //let us know what was tapped from the Experience Reality composer file
        print(entity.name.debugDescription)
        
        
        //if the touch is on the printer toggel sign off and on
        if entity.name == "printerObj" {
            
            if let sign1Obj = self.printerSceneAnchor.sign1Obj {
                
                sign1Obj.isEnabled = (sign1Obj.isEnabled) ? false : true
                
            }
            
        }
        
        
    }
    
    
}



struct ContentOverlay: View {

    var body: some View {

        ZStack {
        
            RoundedRectangle(cornerRadius: 25, style: .continuous)
                .fill(.white.opacity(0.8))
            
            VStack {
                Text("Some Popup Text")
                    .foregroundColor(.black)
                    .font(.largeTitle)
                    .padding()
                Image(systemName: "folder")
                    .foregroundColor(.gray)
                    .padding()
            
            }
        }
        
        
        
    }
}



#if DEBUG
struct ContentView_Previews : PreviewProvider {
    static var previews: some View {
        ContentView()
    }
}
#endif



// @TODO: move this to extension class

//MARK: AR View Touch Event Extention

extension ARView{
    
    func setupGestures() {
        let tap = UITapGestureRecognizer(target: self, action: #selector(self.handleTap(_:)))
        self.addGestureRecognizer(tap)
    }
    
    @objc func handleTap(_ sender: UITapGestureRecognizer? = nil) {
        guard let coordinator = self.session.delegate as? ARViewCoordinator else{ print("arscene coordinator error"); return }
        guard let touchInView = sender?.location(in: self) else {
            return
        }

        let entities = self.entities(at: touchInView)
        
        //print(self.entity(at: touchInView)?.name.debugDescription ?? "")
        //print(self.entity(at: touchInView)?.position.debugDescription ?? "")
        
        //for single entitle
        if let entityTouched = self.entity(at: touchInView) {
            
            coordinator.tapHandler(entity: entityTouched)

        }
        
        //for multitple entities
        if !entities.isEmpty {
            
        }
    }
}


//MARK: Coordinator -- pass touch events back from  arview

class ARViewCoordinator: NSObject, ARSessionDelegate {
    var parent: ARViewContainer
    
    init(container: ARViewContainer) {
        self.parent = container
    }
    
    public func tapHandler( entity : Entity){

        self.parent.tapHandler(entity: entity)
        

    }

}
